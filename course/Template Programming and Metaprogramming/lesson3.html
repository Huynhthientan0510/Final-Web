<!DOCTYPE html>
<html lang="en">
<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>C++ Online Course - Lesson 3</title>
		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
		<!-- FontAwesome Icons -->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
		<!-- Animate.css -->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
		<!-- Custom CSS -->
		<link rel="stylesheet" href="styles.css">
</head>
<body>
		<!-- Navigation Bar -->
		<nav class="navbar navbar-expand-lg navbar-dark bg-primary sticky-top">
				<a class="navbar-brand" href="#"><i class="fas fa-code"></i> C++ Online Learning</a>
				<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"             aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
						<span class="navbar-toggler-icon"></span>
				</button>
				<div class="collapse navbar-collapse animate__animated animate__fadeIn" id="navbarNav">
						<ul class="navbar-nav ml-auto">
								<li class="nav-item active">
										<a class="nav-link" href="#">Home <span class="sr-only">(current)</span></a>
								</li>
								<li class="nav-item">
										<a class="nav-link" href="#">Courses</a>
								</li>
								<li class="nav-item">
										<a class="nav-link" href="#">Community</a>
								</li>
								<li class="nav-item">
										<a class="nav-link" href="#">Contact Us</a>
								</li>
						</ul>
				</div>
		</nav>

		<!-- Header Image -->
		<header class="header-image text-white text-center">
				<div class="header-content">
						<h1 class="animate__animated animate__fadeInDown">Welcome to Course: Template Programming and Metaprogramming</h1>
						<p class="animate__animated animate__fadeInUp">Master the basics of C++ programming with our comprehensive lessons.</p>
						<a href="#lesson-content" class="btn btn-lg btn-light mt-3 animate__animated animate__fadeInUp"><i class="fas fa-chevron-down"></i> Get Started</a>
				</div>
		</header>

		<!-- Main Content -->
		<div class="container mt-5" id="lesson-content">
				<div class="lesson-section">
						<!-- Lesson Title -->
						<h1 class="lesson-title text-center animate__animated animate__fadeInUp">Lesson 3: Template Specialization</h1>

						<!-- Introduction -->
						<section class="animate__animated animate__fadeInLeft">
								<h2><i class="fas fa-lightbulb"></i> Introduction</h2>
								<p>Template specialization is a powerful feature in C++ that allows you to create a tailored implementation of a template for a specific type. While templates are designed to work with any data type, there are situations where you want different behavior for particular types. Template specialization allows you to override the default template behavior in these cases.</p>
						</section>

						<!-- Purpose of the Lesson -->
						<section class="animate__animated animate__fadeInRight">
								<h2><i class="fas fa-bullseye"></i> Purpose of the Lesson</h2>
								<p>This lesson will focus on the concept of template specialization, including when and why to use it. By the end of the lesson, you will:</p>
								<ul>
									<li>Understand the difference between full and partial specialization. </li>
									<li>Learn how to apply template specialization to functions and classes. </li>
									<li>Recognize real-world use cases for specialization in complex systems.</li>
								</ul>
						</section>

						<!-- Detailed Explanation -->
						<section class="animate__animated animate__fadeInLeft">
								<h2><i class="fas fa-book-open"></i> Detailed Explanation</h2>
								<p> <strong>Full Template Specialization</strong></p>
								<p> Full template specialization occurs when you create a specific implementation of a template for a particular type. Let’s consider an example:</p>
								<pre><code>
template &lt;typename T&gt;
class Printer {
public:
	void print(T value) {
		cout << "Generic print: " << value << endl;
	}
};

// Specialization for type `char*`
template &lt;&gt;
class Printer<char*> {
public:
	void print(char* value) {
		cout << "Specialized print for char*: " << value << endl;
	}
};
</code></pre>
						<p> Explanation:</p>
								<ul>
									<li> The <code> Printer </code> template is defined for a generic type <code> T </code>. It prints the value passed to it.</li>
									<li> However, the behavior is specialized for <code> char* </code> (C-style strings). Instead of using the generic <code> Printer&lt;T&gt; </code>  implementation, the specialized <code> Printer&lt;char*&gt; </code>  is used for character pointers. </li>
									<li>The template &lt;&gt; syntax indicates full specialization, and the specialized class has a completely different implementation. </li>
								</ul>
								<p>Example usage:</p>
								<pre><code>
int main() {
	Printer&lt;int&gt; intPrinter;
	intPrinter.print(123);  // Calls generic version

	Printer&lt;char*&gt; charPrinter;
	charPrinter.print("Hello, world!");  // Calls specialized version

	return 0;
}</code></pre>
						<p> Explanation:</p>
						<ul>
							<li>The <code> intPrinter.print(123)</code> call uses the generic version of the <code> print() </code> function, while <code> charPrinter.print("Hello, world!") </code> uses the specialized version for <code> char* </code>. </li>
						</ul>	

						<p> <strong> Function Template Specialization </strong>. </p>
						<p>You can also specialize individual function templates. Here’s an example of full function specialization: </p>
						<pre><code>
template &lt;typename T&gt;
void display(const T& value) {
	cout << "Generic display: " << value << endl;
}

// Full specialization for `double`
template &lt;&gt;
void display(const double& value) {
	cout << "Specialized display for double: " << value << endl;
}</code></pre>
						<p> Explanation:</p>
						<ul>
							<li>The function <code> display() </code> is specialized for the type <code> double </code>. Whenever <code> display() </code> is called with a <code> double </code>, the specialized version is invoked instead of the generic version. </li>
						</ul>	
						<p>Example usage:</p>
								<pre><code>
int main() {
	display(100);         // Calls generic version
	display(3.14159);     // Calls specialized version for double
	return 0;
}</code></pre>
							<p> Explanation:</p>
								<ul>
									<li>The call to <code> display(100) </code> uses the generic template, while <code> display(3.14159) </code> uses the specialized version for <code> double </code>.</li>
									
								</ul>

							<p> <strong> Partial Template Specialization </strong>. </p>
						<p>Partial template specialization allows you to specialize only part of a template’s behavior, rather than fully replacing it. This is especially useful when dealing with templates that accept multiple template parameters. Let’s look at an example of partial class specialization: </p>
						<pre><code>
template &lt;typename T, typename U&gt;
class Pair {
	T first;
	U second;
public:
	Pair(T a, U b) : first(a), second(b) {}
	void print() {
		cout << "Generic Pair: " << first << ", " << second << endl;
	}
};

// Partial specialization for the case where both types are the same
template &lt;typename T&gt;
class Pair&lt;T, T&gt; {
	T first;
	T second;
public:
	Pair(T a, T b) : first(a), second(b) {}
	void print() {
		cout << "Specialized Pair (same types): " << first << ", " << second << endl;
	}
};</code></pre>
								<p> Explanation:</p>
								<ul>
									<li>The <code> Pair </code> class template is specialized for the case where both template parameters are of the same type <code> (T) </code>.</li>
									<li> This allows different behavior when the same type is used for both <code> first </code> and <code> second </code>.</li>
								</ul>

								<p>Example usage:</p>
								<pre><code>
int main() {
	Pair&lt;int, double&gt; p1(10, 20.5);
	p1.print();  // Calls generic version

	Pair&lt;int, int&gt; p2(5, 10);
	p2.print();  // Calls specialized version

	return 0;
}</code></pre>
							<p> Explanation:</p>
							<ul>
								<li> <code> Pair&lt;int, double&gt; </code> uses the generic <code> Pair </code> class template, but <code> Pair&lt;int, int&gt; </code> uses the specialized version because both types are the same. </li>
							</ul>

							<li>Code Example: Specializing Templates for Specific Use Cases </li>
							<p>Sometimes, you need different behavior based on specific types. Let’s look at an example of a template specialization for <code> bool </code>:  </p>
							<pre><code>
template <typename T>
class Printer {
public:
	void print(T value) {
		cout << "Generic print: " << value << endl;
	}
};

// Specialization for `bool`
template &lt;&gt;
class Printer<bool> {
public:
	void print(bool value) {
		cout << (value ? "True" : "False") << endl;
	}
};</code></pre>
							<p> Explanation:</p>
							<ul>
								<li>The <code> Printer </code> template is fully specialized for <code> bool </code> to print <code> "True" </code> or <code> "False" </code> instead of <code> 1 </code> or <code> 0 </code>, which would be printed by the generic version.</li>
							</ul>

							<p> Example Usage:</p>
							<pre><code>
int main() {
	Printer&lt;int&gt; intPrinter;
	intPrinter.print(123);  // Generic print: 123

	Printer&lt;bool&gt; boolPrinter;
	boolPrinter.print(true);  // Specialized print: True

	return 0;
}</code></pre>
							<p> Explanation:</p>
							<ul>
								<li>The specialized <code> Printer&lt;bool&gt; </code> ensures that booleans are printed as <code> True </code> or <code> False </code> instead of <code> 1 </code> or <code> 0 </code>. </li>
							</ul>
						</section>

						<!-- Best Practices and Tips -->
						<section class="animate__animated animate__fadeInRight">
								<h2><i class="fas fa-check-circle"></i> Best Practices and Tips</h2>
								<ul>
										<li> <strong>Use Specialization Sparingly </strong>:Template specialization can lead to code bloat if overused. Only specialize when absolutely necessary to handle a specific type or case. </li>

										<li> <strong>Ensure Consistency</strong>:When specializing templates, make sure that the specialized versions behave consistently with the generic template, to avoid confusion and maintain code readability.</li>

										<li> <strong>Consider Polymorphism as an Alternative </strong>: In some cases, runtime polymorphism (using virtual functions and inheritance) might be a better approach than compile-time specialization.</li>
								</ul>
						</section>

						<!-- Common Mistakes and Pitfalls -->
						<section class="animate__animated animate__fadeInLeft">
								<h2><i class="fas fa-exclamation-triangle"></i> Common Mistakes and Pitfalls</h2>
								<ul>
									<li> <strong>Over-Specialization </strong>:Overusing template specialization can make code harder to maintain and understand. Use it judiciously and only when it simplifies the logic or addresses specific needs. </li>
									<li> <strong>Ambiguous Specializations </strong>: Be careful when combining multiple specializations (full and partial) as they can result in ambiguous or conflicting behavior, which the compiler may struggle to resolve. </li>
								</ul>
						</section>

						<!-- Real-World Applications -->
						<section class="animate__animated animate__fadeInRight">
								<h2><i class="fas fa-briefcase"></i> Real-World Applications</h2>
								<ul>
									<li>Type-Specific Formatting <strong> </strong>:Template specialization is often used in libraries for type-specific formatting. For instance, the standard <code> iostream </code> library uses specialized templates to handle different data types, ensuring that <code> int </code>, <code> double </code>, and <code> char* </code> are printed in different ways. </li>
									<li> <strong>Optimized Algorithms </strong>: In template-based algorithms, specializations can be used to optimize specific cases, such as providing a more efficient sorting algorithm for small arrays or integers. </li>
								</ul>
						</section>

						<!-- Advanced Concepts -->
						<section class="animate__animated animate__fadeInLeft">
								<h2><i class="fas fa-rocket"></i> Advanced Concepts</h2>
								<ul>
									<li> <strong>SFINAE (Substitution Failure Is Not An Error) </strong>:A more advanced technique used in template specialization is SFINAE, which allows the compiler to substitute invalid template arguments without generating a compilation error. This can be used to enable or disable certain template specializations based on type traits or conditions.</li>
								</ul>
								<p>Here’s a brief example:: </p>
								<pre><code>
template &lt;typename T&gt;
typename enable_if&lt;is_integral&lt;T&gt;::value&gt;::type print(T value) {
	cout << "Integral value: " << value << endl;
}</code></pre>
								<p> Explanation: </p>
								<li>This function template uses <code> enable_if </code> and <code> is_integral </code> to ensure that it is only instantiated for integral types. This is a form of conditional template specialization. </li>
							

						</section>

						<!-- Interactive Elements or Quizzes -->
						<section class="animate__animated animate__fadeInRight">
								<h2><i class="fas fa-question-circle"></i> Interactive Quiz</h2>
								<button class="btn btn-primary quiz-btn" onclick="startQuiz()">Start Quiz</button>
						</section>

						<!-- Summary -->
						<section class="animate__animated animate__fadeInLeft">
								<h2><i class="fas fa-stream"></i> Summary</h2>
								<p>Template specialization is an advanced feature in C++ that allows you to fine-tune templates for specific types or situations. By using full or partial specialization, you can handle edge cases, improve performance, or provide different behavior for certain types, all while maintaining the benefits of generic programming.</p>
						</section>

						<!-- Exercises or Challenges -->
						<section class="animate__animated animate__fadeInRight">
								<h2><i class="fas fa-tasks"></i> Exercises</h2>
								<ul>
									<li> <strong> Exercise 1 </strong>:Create a function template for comparing two values and specialize it for <code> std::string </code> to perform case-insensitive comparison. </li>
									<li> <strong> Exercise 2</strong>:Implement a class template for a mathematical vector and specialize it for <code> bool </code> so that it behaves like a bitset. </li>
									
								</ul>
						</section>

						<!-- Further Reading and Resources -->
						<section class="animate__animated animate__fadeInLeft">
								<h2><i class="fas fa-book"></i> Further Reading</h2>
								<li style="margin-left: 20px">Books</li>
								<ul>
									<li style="margin-left: 40px">"C++ Templates: The Complete Guide" by David Vandevoorde and Nicolai M. Josuttis (Chapter on Template Specialization)</li>
									<li style="margin-left: 40px">"Effective C++" by Scott Meyers</li>
								</ul>
								<li style="margin-left: 20px">Online Resources</li>
								<ul>
										<li><a href="https://en.cppreference.com/w/cpp/language/template_specialization" >cppreference: Template Specialization/</a></li>
										<li><a href="http://www.cplusplus.com/doc/oldtutorial/templates/">GeeksforGeeks: Template Specialization</a></li>
								</ul>
						</section>

						<!-- Q&A or Reflection Section -->
						<section class="animate__animated animate__fadeInRight">
								<h2><i class="fas fa-comments"></i> Q&A and Reflection</h2>
								<p>Have questions? Join our community forum to discuss with peers and instructors.</p>
						</section>

						<!-- Project-Based Learning Section -->
						<section class="animate__animated animate__fadeInLeft">
								<h2><i class="fas fa-project-diagram"></i> Project</h2>
								<p>Design a generic matrix class that supports basic operations like addition, subtraction, and multiplication. Then, specialize the template for bool so that the matrix behaves like a logical matrix (i.e., supports logical operations instead of arithmetic operations).</p>
						</section>
				</div>
		</div>

		<!-- Footer -->
		<footer class="bg-primary text-white text-center p-4">
				&copy; SCAM Center All Rights Reserved.
		</footer>

		<!-- JavaScript and Dependencies -->
		<!-- jQuery -->
		<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
		<!-- Bootstrap Bundle JS -->
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
		<!-- Custom JS -->
		<script src="script.js"></script>
</body>
</html>
